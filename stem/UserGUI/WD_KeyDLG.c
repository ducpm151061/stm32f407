/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "DataDefine.h"
#include "UserGUIService.h"
#include "AlcoholMeter.h"
#include "GUI_Text_Define.h"
#include "GUI.h"
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 (GUI_ID_USER + 0x30)
#define ID_TEXT_0 (GUI_ID_USER + 0x31)
#define ID_EDIT_0 (GUI_ID_USER + 0x32)
#define ID_BUTTON_0 (GUI_ID_USER + 0x33)
#define ID_BUTTON_1 (GUI_ID_USER + 0x34)
#define ID_BUTTON_2 (GUI_ID_USER + 0x35)
#define ID_BUTTON_3 (GUI_ID_USER + 0x36)
#define ID_BUTTON_4 (GUI_ID_USER + 0x37)
#define ID_BUTTON_5 (GUI_ID_USER + 0x38)
#define ID_BUTTON_6 (GUI_ID_USER + 0x39)
#define ID_BUTTON_7 (GUI_ID_USER + 0x3A)
#define ID_BUTTON_8 (GUI_ID_USER + 0x3B)
#define ID_BUTTON_9 (GUI_ID_USER + 0x3C)
#define ID_BUTTON_10 (GUI_ID_USER + 0x3D)
#define ID_BUTTON_11 (GUI_ID_USER + 0x3E)
#define ID_BUTTON_12 (GUI_ID_USER + 0x3F)
#define ID_BUTTON_13 (GUI_ID_USER + 0x40)
#define ID_BUTTON_14 (GUI_ID_USER + 0x41)
#define ID_BUTTON_15 (GUI_ID_USER + 0x42)
#define ID_BUTTON_16 (GUI_ID_USER + 0x43)
#define ID_BUTTON_17 (GUI_ID_USER + 0x44)
#define ID_BUTTON_18 (GUI_ID_USER + 0x45)
#define ID_BUTTON_19 (GUI_ID_USER + 0x46)
#define ID_BUTTON_20 (GUI_ID_USER + 0x47)
#define ID_BUTTON_21 (GUI_ID_USER + 0x48)
#define ID_BUTTON_22 (GUI_ID_USER + 0x49)
#define ID_BUTTON_23 (GUI_ID_USER + 0x4A)
#define ID_BUTTON_24 (GUI_ID_USER + 0x4B)
#define ID_BUTTON_25 (GUI_ID_USER + 0x4C)
#define ID_BUTTON_26 (GUI_ID_USER + 0x4D)
#define ID_BUTTON_27 (GUI_ID_USER + 0x4E)
#define ID_BUTTON_28 (GUI_ID_USER + 0x4F)
#define ID_BUTTON_29 (GUI_ID_USER + 0x50)
#define ID_BUTTON_30 (GUI_ID_USER + 0x51)
#define ID_BUTTON_31 (GUI_ID_USER + 0x52)
#define ID_BUTTON_32 (GUI_ID_USER + 0x53)
#define ID_BUTTON_33 (GUI_ID_USER + 0x54)
#define ID_BUTTON_34 (GUI_ID_USER + 0x55)
#define ID_BUTTON_35 (GUI_ID_USER + 0x56)
#define ID_BUTTON_36 (GUI_ID_USER + 0x57)
#define ID_BUTTON_37 (GUI_ID_USER + 0x58)
#define ID_BUTTON_38 (GUI_ID_USER + 0x59)
#define ID_BUTTON_39 (GUI_ID_USER + 0x5A)
#define ID_IMAGE_0 (GUI_ID_USER + 0x5B)
#define ID_IMAGE_1 (GUI_ID_USER + 0x5C)

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
extern GUI_CONST_STORAGE GUI_BITMAP bmDelete;
extern GUI_CONST_STORAGE GUI_BITMAP bmIconBackSpace;
extern GUI_CONST_STORAGE GUI_BITMAP bmCombinedShape;
extern GUI_CONST_STORAGE GUI_BITMAP bmIconBack1;
// USER START (Optionally insert additional static data)
static const int useRelease = 1;
const char Aa[2] = {'A', 'a'};
const char Bb[2] = {'B', 'b'};
const char Cc[2] = {'C', 'c'};
const char Dd[2] = {'D', 'd'};
const char Ee[2] = {'E', 'e'};
const char Ff[2] = {'F', 'f'};
const char Gg[2] = {'G', 'g'};
const char Hh[2] = {'H', 'h'};
const char Ii[2] = {'I', 'i'};
const char Jj[2] = {'J', 'j'};
const char Kk[2] = {'K', 'k'};
const char Ll[2] = {'L', 'l'};
const char Mm[2] = {'M', 'm'};
const char Nn[2] = {'N', 'n'};
const char Oo[2] = {'O', 'o'};
const char Pp[2] = {'P', 'p'};
const char Qq[2] = {'Q', 'q'};
const char Rr[2] = {'R', 'r'};
const char Ss[2] = {'S', 's'};
const char Tt[2] = {'T', 't'};
const char Uu[2] = {'U', 'u'};
const char Vv[2] = {'V', 'v'};
const char Xx[2] = {'X', 'x'};
const char Yy[2] = {'Y', 'y'};
const char Zz[2] = {'Z', 'z'};
const char Ww[2] = {'W', 'w'};

// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] =
    {
        {WINDOW_CreateIndirect, "WD_Key", ID_WINDOW_0, 0, 20, 320, 460, 0, 0x0, 0},
        {TEXT_CreateIndirect, "TxtHeader", ID_TEXT_0, 0, 0, 320, 30, 0, 0x0, 0},
        {EDIT_CreateIndirect, "Edit", ID_EDIT_0, 21, 62, 278, 45, 0, 0x32, 0},
        {BUTTON_CreateIndirect, "A", ID_BUTTON_0, 4, 116, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "B", ID_BUTTON_1, 49, 116, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "C", ID_BUTTON_2, 94, 116, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "D", ID_BUTTON_3, 140, 116, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "E", ID_BUTTON_4, 185, 116, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "F", ID_BUTTON_5, 230, 116, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "G", ID_BUTTON_6, 4, 161, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "H", ID_BUTTON_7, 49, 161, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "I", ID_BUTTON_8, 94, 161, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "J", ID_BUTTON_9, 140, 161, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "K", ID_BUTTON_10, 185, 161, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "L", ID_BUTTON_11, 230, 161, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "M", ID_BUTTON_12, 4, 206, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "N", ID_BUTTON_13, 49, 206, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "O", ID_BUTTON_14, 94, 206, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "P", ID_BUTTON_15, 140, 206, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "Q", ID_BUTTON_16, 185, 206, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "R", ID_BUTTON_17, 230, 206, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "S", ID_BUTTON_18, 4, 251, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "T", ID_BUTTON_19, 49, 251, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "U", ID_BUTTON_20, 94, 251, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "V", ID_BUTTON_21, 140, 251, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "W", ID_BUTTON_22, 185, 251, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "X", ID_BUTTON_23, 230, 251, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "Y", ID_BUTTON_24, 4, 296, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "Z", ID_BUTTON_25, 49, 296, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "1", ID_BUTTON_26, 94, 296, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "2", ID_BUTTON_27, 140, 296, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "3", ID_BUTTON_28, 185, 296, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "4", ID_BUTTON_29, 230, 296, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "5", ID_BUTTON_30, 4, 341, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "6", ID_BUTTON_31, 49, 341, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "7", ID_BUTTON_32, 94, 341, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "8", ID_BUTTON_33, 140, 341, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "9", ID_BUTTON_34, 185, 341, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "0", ID_BUTTON_35, 230, 341, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "", ID_BUTTON_36, 274, 116, 42, 87, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "", ID_BUTTON_37, 274, 206, 42, 87, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "Abc", ID_BUTTON_38, 274, 296, 42, 42, 0, 0x0, 0},
        {BUTTON_CreateIndirect, "", ID_BUTTON_39, 274, 341, 42, 42, 0, 0x0, 0},
        {IMAGE_CreateIndirect, "Image", ID_IMAGE_0, 13, 410, 42, 42, 0, 0, 0},
        {IMAGE_CreateIndirect, "Image", ID_IMAGE_1, 267, 410, 42, 42, 0, 0, 0},
        // USER START (Optionally insert additional widgets)
        // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
uint8_t Tmp;

static WM_HWIN ID_Text_handle;

void CharReplace(unsigned char *NewChar)
{
    uint8_t i;
    uint16_t CharCode, CharSize, OldCharSize;

    CharSize = GUI_UC_GetCharSize((const char *)NewChar); //(const char*)&Unicode[*Index]);
    CharCode = GUI_UC_GetCharCode((const char *)NewChar); //(const char*)&Unicode[*Index]);
    OldCharSize = GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]);

    for (i = 0; i < CharSize; i++)
        xSystem.Keypad.Str[xSystem.Keypad.Index + i] = NewChar[i];
    xSystem.Keypad.Code = CharCode;
    DebugPrint("\rCharSize:%d, OldCharSize:%d, NewChar:%x\r\n", CharSize, OldCharSize, *NewChar);
    //xSystem.Keypad.Index+=CharSize-OldCharSize;
    xSystem.Keypad.CharLen = CharSize;
}

void CharAdd(unsigned short NewChar)
{
    uint16_t CharCode, CharSize, OldCharSize, OldCharCode;

    CharSize = GUI_UC_GetCharSize((const char *)&NewChar); //(const char*)&Unicode[*Index]);
    CharCode = GUI_UC_GetCharCode((const char *)&NewChar); //(const char*)&Unicode[*Index]);
    OldCharSize = GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]);
    OldCharCode = GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]);

    if (xSystem.Keypad.StrLen == 0)
    {
        xSystem.Keypad.Str[0] = NewChar;
        xSystem.Keypad.Index = 0;
        xSystem.Keypad.StrLen = CharSize;
        xSystem.Keypad.Code = CharCode;
        xSystem.Keypad.CharLen = CharSize;
        return;
    }
    if (OldCharCode != 0)
        xSystem.Keypad.Index += OldCharSize;
    DebugPrint("\rOldCharSize:%d\r\n", OldCharSize);
    if (CharSize == 1)
    {
        xSystem.Keypad.Str[xSystem.Keypad.Index % KPI_CONTENTSIZE] = NewChar;
        xSystem.Keypad.Str[xSystem.Keypad.Index % KPI_CONTENTSIZE + 1] = 0x0;
    }
    else if (CharSize == 2)
    {
        *(unsigned short *)&xSystem.Keypad.Str[xSystem.Keypad.Index] = NewChar;
    }
    xSystem.Keypad.Code = CharCode;
    xSystem.Keypad.CharLen = CharSize;
}
#define VIETNAMESE_KEYBOARD_SUPPORT 1
static uint32_t lastKeyPressTime = 0;
void ProgressKeyChar(char Character)
{
    uint16_t Char = 0, Tmplc = 0;
    uint32_t currentKeyPressTime = xSystem.TickCount1Ms;
    //xSystem.CTP.CTP_Sens = xSystem.CTP.CTP_Sens_DF;
    if (currentKeyPressTime < lastKeyPressTime + KPI_DELAY_MS)
    {
        return;
    }
    lastKeyPressTime = xSystem.TickCount1Ms;
#ifdef VIETNAMESE_KEYBOARD_SUPPORT
    switch (Character)
    {
    case 'a':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'a')
            CharReplace((unsigned char *)_aa);
        else
            CharAdd('a');
        break;
    case 'd':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'd')
            CharReplace((unsigned char *)_dd);
        else
            CharAdd('d');
        break;

    case 'e':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'e')
            CharReplace((unsigned char *)_ee);
        else
            CharAdd('e');
        break;

    case 'o':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'o')
            CharReplace((unsigned char *)_oo);
        else
            CharAdd('o');
        break;

    case 'w':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'a')
            CharReplace((unsigned char *)_aw);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'o')
            CharReplace((unsigned char *)_ow);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'u')
            CharReplace((unsigned char *)_uw);
        else
            CharAdd('w');
        break;

    case 'f':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'a')
            CharReplace((unsigned char *)_af);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'e')
            CharReplace((unsigned char *)_ef);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'i')
            CharReplace((unsigned char *)_if);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'o')
            CharReplace((unsigned char *)_of);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'u')
            CharReplace((unsigned char *)_uf);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'y')
            CharReplace((unsigned char *)_yf);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aw))
            CharReplace((unsigned char *)_awf);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aa))
            CharReplace((unsigned char *)_aaf);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ee))
            CharReplace((unsigned char *)_eef);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owf);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_oo))
            CharReplace((unsigned char *)_oof);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owf);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_uw))
            CharReplace((unsigned char *)_uwf);
        else
            CharAdd('f');
        break;

    case 's':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'a')
            CharReplace((unsigned char *)_as);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'e')
            CharReplace((unsigned char *)_es);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'i')
            CharReplace((unsigned char *)_is);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'o')
            CharReplace((unsigned char *)_os);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'u')
            CharReplace((unsigned char *)_us);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'y')
            CharReplace((unsigned char *)_ys);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aw))
            CharReplace((unsigned char *)_aws);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aa))
            CharReplace((unsigned char *)_aas);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ee))
            CharReplace((unsigned char *)_eef);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_ows);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_oo))
            CharReplace((unsigned char *)_oos);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_ows);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_uw))
            CharReplace((unsigned char *)_uws);

        else
            CharAdd('s');
        break;

    case 'r':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'a')
            CharReplace((unsigned char *)_ar);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'e')
            CharReplace((unsigned char *)_er);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'i')
            CharReplace((unsigned char *)_ir);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'o')
            CharReplace((unsigned char *)_or);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'u')
            CharReplace((unsigned char *)_ur);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'y')
            CharReplace((unsigned char *)_yr);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aw))
            CharReplace((unsigned char *)_awr);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aa))
            CharReplace((unsigned char *)_aar);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ee))
            CharReplace((unsigned char *)_eer);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owr);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_oo))
            CharReplace((unsigned char *)_oor);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owr);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_uw))
            CharReplace((unsigned char *)_uwr);
        else
            CharAdd('r');
        break;

    case 'x':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'a')
            CharReplace((unsigned char *)_ax);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'e')
            CharReplace((unsigned char *)_ex);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'i')
            CharReplace((unsigned char *)_ix);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'o')
            CharReplace((unsigned char *)_ox);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'u')
            CharReplace((unsigned char *)_ux);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'y')
            CharReplace((unsigned char *)_yx);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aw))
            CharReplace((unsigned char *)_awx);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aa))
            CharReplace((unsigned char *)_aax);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ee))
            CharReplace((unsigned char *)_eex);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owx);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_oo))
            CharReplace((unsigned char *)_oox);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owx);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_uw))
            CharReplace((unsigned char *)_uwx);
        else
            CharAdd('x');
        break;

    case 'j':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'a')
            CharReplace((unsigned char *)_aj);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'e')
            CharReplace((unsigned char *)_ej);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'i')
            CharReplace((unsigned char *)_ij);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'o')
            CharReplace((unsigned char *)_oj);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'u')
            CharReplace((unsigned char *)_uj);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'y')
            CharReplace((unsigned char *)_yj);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aw))
            CharReplace((unsigned char *)_awj);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_aa))
            CharReplace((unsigned char *)_aaj);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ee))
            CharReplace((unsigned char *)_eej);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owj);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_oo))
            CharReplace((unsigned char *)_ooj);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_ow))
            CharReplace((unsigned char *)_owj);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_uw))
            CharReplace((unsigned char *)_uwj);
        else
            CharAdd('j');
        break;
    case 'A':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'A')
            CharReplace((unsigned char *)_AA);
        else
            CharAdd('A');
        break;

    case 'D':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'D')
            CharReplace((unsigned char *)_DD);
        else
            CharAdd('D');
        break;

    case 'E':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'E')
            CharReplace((unsigned char *)_EE);
        else
            CharAdd('E');
        break;

    case 'O':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'O')
            CharReplace((unsigned char *)_OO);
        else
            CharAdd('O');
        break;

    case 'W':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'A')
            CharReplace((unsigned char *)_AW);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'O')
            CharReplace((unsigned char *)_OW);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'U')
            CharReplace((unsigned char *)_UW);
        else
            CharAdd('W');
        break;

    case 'F':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'A')
            CharReplace((unsigned char *)_AF);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'E')
            CharReplace((unsigned char *)_EF);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'I')
            CharReplace((unsigned char *)_IF);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'O')
            CharReplace((unsigned char *)_OF);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'U')
            CharReplace((unsigned char *)_UF);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'Y')
            CharReplace((unsigned char *)_YF);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AW))
            CharReplace((unsigned char *)_AWF);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AA))
            CharReplace((unsigned char *)_AAF);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_EE))
            CharReplace((unsigned char *)_EEF);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OW))
            CharReplace((unsigned char *)_OWF);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OO))
            CharReplace((unsigned char *)_OOF);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_UW))
            CharReplace((unsigned char *)_UWF);
        else
            CharAdd('F');
        break;

    case 'S':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'A')
            CharReplace((unsigned char *)_AS);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'E')
            CharReplace((unsigned char *)_ES);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'I')
            CharReplace((unsigned char *)_IS);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'O')
            CharReplace((unsigned char *)_OS);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'U')
            CharReplace((unsigned char *)_US);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'Y')
            CharReplace((unsigned char *)_YS);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AW))
            CharReplace((unsigned char *)_AWS);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AA))
            CharReplace((unsigned char *)_AAS);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_EE))
            CharReplace((unsigned char *)_EEF);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OW))
            CharReplace((unsigned char *)_OWS);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OO))
            CharReplace((unsigned char *)_OOS);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_UW))
            CharReplace((unsigned char *)_UWS);

        else
            CharAdd('S');
        break;

    case 'R':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'A')
            CharReplace((unsigned char *)_AR);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'E')
            CharReplace((unsigned char *)_ER);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'I')
            CharReplace((unsigned char *)_IR);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'O')
            CharReplace((unsigned char *)_OR);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'U')
            CharReplace((unsigned char *)_UR);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'Y')
            CharReplace((unsigned char *)_YR);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AW))
            CharReplace((unsigned char *)_AWR);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AA))
            CharReplace((unsigned char *)_AAR);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_EE))
            CharReplace((unsigned char *)_EER);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OW))
            CharReplace((unsigned char *)_OWR);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OO))
            CharReplace((unsigned char *)_OOR);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_UW))
            CharReplace((unsigned char *)_UWR);
        else
            CharAdd('R');
        break;

    case 'X':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'A')
            CharReplace((unsigned char *)_AX);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'E')
            CharReplace((unsigned char *)_EX);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'I')
            CharReplace((unsigned char *)_IX);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'O')
            CharReplace((unsigned char *)_OX);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'U')
            CharReplace((unsigned char *)_UX);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'Y')
            CharReplace((unsigned char *)_YX);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AW))
            CharReplace((unsigned char *)_AWX);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AA))
            CharReplace((unsigned char *)_AAX);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_EE))
            CharReplace((unsigned char *)_EEX);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OW))
            CharReplace((unsigned char *)_OWX);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OO))
            CharReplace((unsigned char *)_OOX);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_UW))
            CharReplace((unsigned char *)_UWX);
        else
            CharAdd('X');
        break;

    case 'J':
        if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'A')
            CharReplace((unsigned char *)_AJ);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'E')
            CharReplace((unsigned char *)_EJ);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'I')
            CharReplace((unsigned char *)_IJ);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'O')
            CharReplace((unsigned char *)_OJ);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'U')
            CharReplace((unsigned char *)_UJ);
        else if (xSystem.Keypad.Str[xSystem.Keypad.Index] == 'Y')
            CharReplace((unsigned char *)_YJ);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AW))
            CharReplace((unsigned char *)_AWJ);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_AA))
            CharReplace((unsigned char *)_AAJ);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_EE))
            CharReplace((unsigned char *)_EEJ);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OW))
            CharReplace((unsigned char *)_OWJ);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_OO))
            CharReplace((unsigned char *)_OOJ);
        else if (GUI_UC_GetCharCode((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == GUI_UC_GetCharCode(_UW))
            CharReplace((unsigned char *)_UWJ);
        else
            CharAdd('J');
        break;

    default:
        if ((xSystem.Keypad.Str[xSystem.Keypad.Index] == ' ' || (xSystem.Keypad.Index == 0 && xSystem.Keypad.Str[xSystem.Keypad.Index] == 0)) && xSystem.Keypad.CAP_State == 1)
        {
            if (Character >= 'a' && Character <= 'z')
            {
                Tmplc = Character - 'a';
                Character = 'A' + Tmplc;
            }
        }
        CharAdd(Character);
        break;
    }
#else
    if ((xSystem.Keypad.Str[xSystem.Keypad.Index] == ' ' || (xSystem.Keypad.Index == 0 && xSystem.Keypad.Str[xSystem.Keypad.Index] == 0)) && xSystem.Keypad.CAP_State == 1)
    {
        if (Character >= 'a' && Character <= 'z')
        {
            Tmplc = Character - 'a';
            Character = 'A' + Tmplc;
        }
    }
    CharAdd(Character);
#endif
    DebugPrint("%d Index: %d, CharLen:%d, Code:%x\r\n", xSystem.TickCount1Ms, xSystem.Keypad.Index, xSystem.Keypad.CharLen, xSystem.Keypad.Code);
    BeepKeypad();
    EDIT_SetText(ID_Text_handle, (char *)xSystem.Keypad.Str);
    lastKeyPressTime = xSystem.TickCount1Ms;
}

// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE *pMsg)
{
    WM_HWIN hItem;
    int NCode;
    int Id;
    // USER START (Optionally insert additional variables)
    // USER END

    switch (pMsg->MsgId)
    {
    case WM_INIT_DIALOG:
        //
        // Initialization of 'TxtHeader'
        //
        hItem = pMsg->hWin;
        WINDOW_SetBkColor(hItem, GUI_MAKE_COLOR(0x00FFEFDC));

        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
        TEXT_SetFont(hItem, &GUI_FontArial21);
        TEXT_SetBkColor(hItem, GUI_MAKE_COLOR(0xFFEBC0));
        //
        // Initialization of 'Edit'
        //
        hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
        EDIT_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
        // USER START (Optionally insert additional code for further widget initialization)
        ID_Text_handle = hItem;
        EDIT_SetText(ID_Text_handle, (const char *)xSystem.Keypad.Str);
        EDIT_SetFont(ID_Text_handle, &GUI_FontArial24);
        // Find Index
        DebugPrint("\rStr[%d]: %s\r\n", xSystem.Keypad.StrLen, xSystem.Keypad.Str);
        xSystem.Keypad.Index = 0;
        do
        {
            if (xSystem.Keypad.Index + GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]) == xSystem.Keypad.StrLen)
            {
                break;
            }
            xSystem.Keypad.Index += GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[xSystem.Keypad.Index]);
        } while (xSystem.Keypad.Index < xSystem.Keypad.StrLen);
        if (xSystem.Keypad.Index >= xSystem.Keypad.StrLen)
        {
            xSystem.Keypad.Index = 0; // Can check 1
            memset(xSystem.Keypad.Str, 0, KPI_CONTENTSIZE);
        }
        DebugPrint("\rTextIndex: %d\r\n", xSystem.Keypad.Index);

        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        TEXT_SetText(hItem, (const char *)xSystem.Keypad.Header);
        TEXT_SetFont(hItem, &GUI_FontArial21);
        TEXT_SetBkColor(hItem, GUI_MAKE_COLOR(0xFFEBC0));

        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_38);
        if (xSystem.Keypad.CAP_State == 0)
            BUTTON_SetText(hItem, "ABC");
        else if (xSystem.Keypad.CAP_State == 1)
            BUTTON_SetText(hItem, "Abc");
        else
            BUTTON_SetText(hItem, "abc");

        hItem = WM_GetDialogItem(pMsg->hWin, ID_IMAGE_0);
        IMAGE_SetBitmap(hItem, &bmIconBack1);

        hItem = WM_GetDialogItem(pMsg->hWin, ID_IMAGE_1);
        IMAGE_SetBitmap(hItem, &bmIconNext);

        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_36);
        BUTTON_SetBitmapEx(hItem, BUTTON_BI_UNPRESSED, &bmIconBackSpace, 9, 35);

        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_37);
        BUTTON_SetBitmapEx(hItem, BUTTON_BI_UNPRESSED, &bmCombinedShape, 11, 41);

        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_39);
        BUTTON_SetBitmapEx(hItem, BUTTON_BI_UNPRESSED, &bmDelete, 13, 12);
        // USER END
        break;
    case WM_NOTIFY_PARENT:
        Id = WM_GetId(pMsg->hWinSrc);
        NCode = pMsg->Data.v;
        switch (Id)
        {
        case ID_EDIT_0: // Notifications sent by 'Edit'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                // USER END
                break;
            case WM_NOTIFICATION_VALUE_CHANGED:
                // USER START (Optionally insert code for reacting on notification message)
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_0: // Notifications sent by 'A'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
            {
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Aa[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
            }
            break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Aa[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_1: // Notifications sent by 'B'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Bb[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Bb[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_2: // Notifications sent by 'C'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Cc[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Cc[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_3: // Notifications sent by 'D'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Dd[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Dd[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_4: // Notifications sent by 'E'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Ee[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Ee[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_5: // Notifications sent by 'F'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Ff[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Ff[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_6: // Notifications sent by 'G'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Gg[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Gg[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_7: // Notifications sent by 'H'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Hh[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Hh[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_8: // Notifications sent by 'I'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Ii[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Ii[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_9: // Notifications sent by 'J'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Jj[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Jj[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_10: // Notifications sent by 'K'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Kk[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Kk[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_11: // Notifications sent by 'L'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Ll[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Ll[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_12: // Notifications sent by 'M'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Mm[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Mm[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_13: // Notifications sent by 'N'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Nn[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Nn[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_14: // Notifications sent by 'O'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Oo[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Oo[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_15: // Notifications sent by 'P'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Pp[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Pp[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_16: // Notifications sent by 'Q'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Qq[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Qq[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_17: // Notifications sent by 'R'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Rr[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Rr[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_18: // Notifications sent by 'S'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Ss[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Ss[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_19: // Notifications sent by 'T'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Tt[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Tt[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_20: // Notifications sent by 'U'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Uu[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Uu[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_21: // Notifications sent by 'V'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Vv[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Vv[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_22: // Notifications sent by 'W'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Ww[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Ww[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_23: // Notifications sent by 'X'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Xx[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Xx[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_24: // Notifications sent by 'Y'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Yy[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Yy[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_25: // Notifications sent by 'Z'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(Zz[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(Zz[xSystem.Keypad.CAP_State != 0]);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_26: // Notifications sent by '1'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('1');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('1');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_27: // Notifications sent by '2'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('2');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('2');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_28: // Notifications sent by '3'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('3');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('3');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_29: // Notifications sent by '4'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('4');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('4');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_30: // Notifications sent by '5'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('5');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('5');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_31: // Notifications sent by '6'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('6');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('6');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_32: // Notifications sent by '7'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('7');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('7');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_33: // Notifications sent by '8'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('8');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('8');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_34: // Notifications sent by '9'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('9');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('9');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_35: // Notifications sent by '0'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar('0');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar('0');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_36: // Notifications sent by '<'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    xSystem.CTP.CTP_Sens = xSystem.CTP.CTP_Sens_DF;
                    if (xSystem.Keypad.Index > 0)
                    {
                        //=GUI_UC_GetCharSize((const char*)&xSystem.Keypad.Str[xSystem.Keypad.Index]) ) {
                        xSystem.Keypad.Str[xSystem.Keypad.Index] = 0;
                        xSystem.Keypad.Str[xSystem.Keypad.Index + 1] = 0;
                        Tmp = 0;
                        do
                        {
                            if (Tmp + GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[Tmp]) == xSystem.Keypad.Index)
                            {
                                xSystem.Keypad.Index -= GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[Tmp]);
                                break;
                            }
                            Tmp += GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[Tmp]);
                        } while (Tmp < xSystem.Keypad.Index);
                        if (Tmp > xSystem.Keypad.Index)
                            xSystem.Keypad.Index -= 1;
                    }
                    else
                    {
                        xSystem.Keypad.Str[0] = 0;
                        xSystem.Keypad.StrLen = 0;
                    }
                    DebugPrint("XXXX xSystem.Keypad.Index: %d %s:%d\r\n", xSystem.Keypad.Index, __FILE__, __LINE__);
                    EDIT_SetText(ID_Text_handle, (char *)xSystem.Keypad.Str);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    uint32_t currentKeyPressTime = xSystem.TickCount1Ms;
                    if (currentKeyPressTime < lastKeyPressTime + KPI_DELAY_MS)
                    {
                        break;
                    }
                    //xSystem.CTP.CTP_Sens = xSystem.CTP.CTP_Sens_DF;
                    BeepKeypad();
                    if (xSystem.Keypad.Index > 0)
                    {
                        //=GUI_UC_GetCharSize((const char*)&xSystem.Keypad.Str[xSystem.Keypad.Index]) ) {
                        xSystem.Keypad.Str[xSystem.Keypad.Index] = 0;
                        xSystem.Keypad.Str[xSystem.Keypad.Index + 1] = 0;
                        Tmp = 0;
                        do
                        {
                            if (Tmp + GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[Tmp]) == xSystem.Keypad.Index)
                            {
                                xSystem.Keypad.Index -= GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[Tmp]);
                                break;
                            }
                            Tmp += GUI_UC_GetCharSize((const char *)&xSystem.Keypad.Str[Tmp]);
                        } while (Tmp < xSystem.Keypad.Index);
                        if (Tmp > xSystem.Keypad.Index && xSystem.Keypad.Index > 0)
                        {
                            xSystem.Keypad.Index -= 1;
                        }
                        xSystem.Keypad.Str[xSystem.Keypad.Index + 1] = 0;
                    }
                    else
                    {
                        xSystem.Keypad.Str[0] = 0;
                        xSystem.Keypad.StrLen = 0;
                    }
                    //DebugPrint("xSystem.Keypad.Index: %d %s:%d\r\n", xSystem.Keypad.Index, __FILE__, __LINE__);
                    EDIT_SetText(ID_Text_handle, (char *)xSystem.Keypad.Str);
                    lastKeyPressTime = xSystem.TickCount1Ms;
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_37: // Notifications sent by '_'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    ProgressKeyChar(' ');
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    ProgressKeyChar(' ');
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_38: // Notifications sent by 'Abc'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    xSystem.CTP.CTP_Sens = 2 * xSystem.CTP.CTP_Sens_DF;
                    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_38);
                    if (xSystem.Keypad.CAP_State == 0)
                    {
                        xSystem.Keypad.CAP_State = 1;
                        BUTTON_SetText(hItem, "Abc");
                    }
                    else if (xSystem.Keypad.CAP_State == 1)
                    {
                        xSystem.Keypad.CAP_State = 2;
                        BUTTON_SetText(hItem, "abc");
                    }
                    else
                    {
                        xSystem.Keypad.CAP_State = 0;
                        BUTTON_SetText(hItem, "ABC");
                    }
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    uint32_t currentKeyPressTime = xSystem.TickCount1Ms;
                    if (currentKeyPressTime < lastKeyPressTime + 75)
                    {
                        break;
                    }
                    lastKeyPressTime = currentKeyPressTime;
                    xSystem.CTP.CTP_Sens = 2 * xSystem.CTP.CTP_Sens_DF;
                    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_38);
                    if (xSystem.Keypad.CAP_State == 0)
                    {
                        xSystem.Keypad.CAP_State = 1;
                        BUTTON_SetText(hItem, "Abc");
                    }
                    else if (xSystem.Keypad.CAP_State == 1)
                    {
                        xSystem.Keypad.CAP_State = 2;
                        BUTTON_SetText(hItem, "abc");
                    }
                    else
                    {
                        xSystem.Keypad.CAP_State = 0;
                        BUTTON_SetText(hItem, "ABC");
                    }
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        case ID_BUTTON_39: // Notifications sent by 'Rc'
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                if (!useRelease)
                {
                    memset(xSystem.Keypad.Str, 0, KPI_CONTENTSIZE);
                    xSystem.Keypad.Index = 0;
                    EDIT_SetText(ID_Text_handle, (char *)xSystem.Keypad.Str);
                }
                // USER END
                break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                if (useRelease)
                {
                    memset(xSystem.Keypad.Str, 0, KPI_CONTENTSIZE);
                    xSystem.Keypad.Index = 0;
                    EDIT_SetText(ID_Text_handle, (char *)xSystem.Keypad.Str);
                }
                // USER END
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        // USER START (Optionally insert additional code for further Ids)
        // Next button
        case ID_IMAGE_1:
            if (NCode == WM_NOTIFICATION_RELEASED)
            {
                switch (xSystem.Keypad.WD_Req)
                {
                case WD_KQ_REPORT:
                    if (NCode == WM_NOTIFICATION_RELEASED)
                    {
                        xSystem.Keypad.Status = KP_ENTER;
                        xSystem.Keypad.Type_Req = KP_REQ_TEXT;
                        xSystem.CTP.CTP_Sens = 2 * xSystem.CTP.CTP_Sens_DF;
                        WD_RP_Process_Enter();
                    }
                    break;
                case WD_CaiDatChung:
                    if (NCode == WM_NOTIFICATION_RELEASED)
                    {
                        xSystem.Keypad.Status = KP_ENTER;
                        xSystem.Keypad.Type_Req = KP_REQ_TEXT;
                        xSystem.CTP.CTP_Sens = 2 * xSystem.CTP.CTP_Sens_DF;
                        WD_CDC_Process_Enter();
                    }
                    break;
                }
            }
            break;
        // Back button
        case ID_IMAGE_0:
            if (NCode == WM_NOTIFICATION_RELEASED)
            {
                switch (xSystem.Keypad.WD_Req)
                {
                case WD_KQ_REPORT:
                    if (NCode == WM_NOTIFICATION_RELEASED)
                    {
                        xSystem.Keypad.Status = KP_CANCEL;
                        xSystem.Keypad.Type_Req = KP_REQ_TEXT;
                        xSystem.CTP.CTP_Sens = 2 * xSystem.CTP.CTP_Sens_DF;
                        WD_RP_Process_Enter();
                    }
                    break;
                case WD_CaiDatChung:
                    if (NCode == WM_NOTIFICATION_RELEASED)
                    {
                        xSystem.Keypad.Status = KP_CANCEL;
                        xSystem.Keypad.Type_Req = KP_REQ_TEXT;
                        xSystem.CTP.CTP_Sens = 2 * xSystem.CTP.CTP_Sens_DF;
                        WD_CDC_Process_Enter();
                    }
                    break;
                }
            }
            break;
            // USER END
        }
        break;
    // USER START (Optionally insert additional message handling)
    // USER END
    default:
        WM_DefaultProc(pMsg);
        break;
    }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWD_Key
*/
WM_HWIN CreateWD_Key(void);
WM_HWIN CreateWD_Key(void)
{
    WM_HWIN hWin;

    hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
    return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
